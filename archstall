#!/bin/bash
# Archstall Arch Linux installer made by PowerMan2206

# set style variables
red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
blue=$(tput setaf 4)
bold=$(tput bold)
italic=$(tput sitm)
end=$(tput sgr0)

originalDir=$(pwd)
secondScriptName="archstall2"

mountpoint=/mnt

#functions
error() {
	echo "${bold}${red}ERROR:$end $1"
}

invalidoption() {
	error "invalid option!"
}

namepartition() {
	lsblk -rno name | grep "$disk" | sed 1d | sed -n "$1"p
}

autocomplete() {
	cd $(mktemp -d)
	touch $@
}

clear 

echo "${bold}${green}Archstall Arch Linux installer$end"
echo "${red}This script comes with no warranty, screwing up your system is your fault$end"

echo
read -n 1 -sp "Press any key to continue... "
echo; echo

# delet packages file if it already exists
# (little dev stuff)
# ((yes it already gets nuked at the end but shush))
if [[ -f packages ]]; then rm packages; fi

# check the boot mode
if [[ -d /sys/firmware/efi/efivars ]]; then
	echo "System booted in ${bold}UEFI$end mode"
	uefi=true
else
	# notify user is booted in BIOS
	echo "System booted in ${bold}BIOS$end mode"
	echo "Reboot into ${bold}UEFI$end mode if you want to install for that."
fi

echo
read -n 1 -sp "Press any key to continue or Ctrl+C to cancel..."
echo; echo

# set the system clock and wait a bit for the messages
echo "Ensuring the system clock is accurate..."
timedatectl set-ntp true || exit; sleep 1

clear

# unmount any thing in the mountpoint
if [[ $(findmnt "$mountpoint") ]]; then
	echo "Unmounting disks in $mountpoint..."
	umount -R "$mountpoint" || exit
	echo
fi

# for read tab autocomplete
cd /dev

# choose disk
lsblk -dno name,size
echo
while true; do
	read -ep "Select the ${yellow}disk$end you want to use: /dev/" disk
	if   [[ "$(lsblk -dno name)" != *"$disk"* ]] || [[ "$disk" == "" ]]; then 
		error "disk doesn't exist!"
		echo
	elif [[ "$(lsblk -dno name)" == *"$disk"* ]]; then 
		break
	fi
done

# partition disk
while true; do
	autocomplete automatic manual skip
	read -ep "(a)utomatic, (m)anual, or (s)kip disk partitioning? [automatic] " partitioning
	echo
	
	case $partitioning in
		a | automatic | "" )
			if [[ -n "$uefi" ]]; then
				echo "The disk will be partitioned into a 512M ${bold}EFI partition$end and a ${bold}root partition$end that takes up the rest"
			else
				echo "The disk will be partitioned into a single ${bold}root partition$end taking up the entire disk"
			fi
			
			echo
			echo "${bold}${red}WARNING: THIS WILL ERASE EVERYTHING ON THE SELECTED DISK$end"
			read -sp "${red}Are you sure you want to continue?$end You can cancel with Ctrl+C"
			echo
			echo -n "${red}Erasing disk in "
			
			# hell yeah, complications
			for delet in {5..1}; do
				echo -n $delet
				for dot in {1..3}; do
					sleep 0.25
					echo -n .
				done
				sleep 0.5
				echo -n " "
			done
			echo "$end"
			
			echo
			
			if [[ -n "$uefi" ]]; then
				parted -s /dev/"$disk" mklabel gpt || exit
				
				# make EFI partition
				echo "${green}Making the ${bold}EFI partition...$end"
				parted -s /dev/"$disk" mkpart P1 1MiB 512MiB || exit
				efipartition="$(namepartition 1)"
				
				# format EFI partition
				echo "${green}Formatting the EFI partition...$end"
				mkfs.fat -F32 /dev/"$efipartition"

				echo
				
				# make root partition
				echo "${green}Making the ${bold}root partition...$end"
				parted -s /dev/"$disk" mkpart P2 512MiB 100% || exit
				rootpartition="$(namepartition 2)"
			
			else
				parted -s /dev/"$disk" mklabel msdos || exit
				
				# make root partition
				echo "${green}Making the ${bold}root partition...$end"
				parted -s /dev/"$disk" mkpart primary 1MiB 100% || exit
				parted -s /dev/"$disk" set 1 boot on || exit
				rootpartition="$(namepartition 1)"
			fi
			
			break
			;;
		
		m | manual | s | skip )
			case $partitioning in
				m | manual )
					
					autocomplete fdisk cfdisk parted
					
					while true; do
					read -ep "Do you want to use (f)disk, (c)fdisk or (p)arted? [fdisk] " partitioner
					echo
					
					case "$partitioner" in
						f | fdisk | "" ) fdisk /dev/"$disk" || exit; break ;;
						c | cfdisk ) cfdisk /dev/"$disk" || exit; break ;;
						p | parted ) parted /dev/"$disk" || exit; break ;;
						* ) invalidoption ;;	
					esac
					done # while loop
					
					clear
					;;
				s | skip ) echo "Skipping..." ;;
			esac
			
			echo
			
			# this again
			cd /dev
			
			partitions="$(lsblk -rno name,size | grep "$disk" | sed 1d)"
			echo "$partitions"
			echo
			
			while true; do
				read -ep "What's the ${bold}root partition${end}? /dev/" rootpartition
				if [[ "$partitions" != *"$rootpartition"* ]] || [[ "$rootpartition" == "" ]] || [[ "$rootpartition" == "$disk" ]]; then
					error "partition doesn't exist!"
					echo
				else break
				fi
			done # while loop
			
			if [[ -n "$uefi" ]]; then
				echo
				efipartitions="$(lsblk -rno name,size | grep "$disk" | sed 1d | grep -v "$rootpartition")"
				echo "$efipartitions"
				echo
				
				while true; do
					read -ep "What's the ${bold}EFI partition${end}? /dev/" efipartition
					if [[ "$efipartitions" != *"$efipartition"* ]] || [[ "$efipartition" == "" ]] || [[ "$efipartition" == "$disk" ]]; then
						error "partition doesn't exist!"
						echo
					else
						while true; do
							echo
							echo "Do you want to format the ${bold}EFI partition?$end"
							read -p "Don't do this if you set it up beforehand [n] " formatefi
							
							case $formatefi in
								n | no | "" ) echo "${green}Skipping EFI partition formatting...$end"; break ;;
								y | yes )
									echo "${green}Formatting the EFI partition...$end"
									mkfs.fat -F32 "$efipartition"
									break
									;;
							esac
						done # while loop		# this
						break					# is
					fi							# a
				done # while loop				# beautiful
			fi									# mess
			break								# lmao
			;;
	esac
done

echo

# some luks stuff
while true; do
	read -p "Use LUKS1 encryption on the root partition? [n] " luks
	echo
	case "$luks" in
		y | yes )
			echo "${green}Encrypting /dev/$rootpartition...$end"
			while true; do
				if ! cryptsetup -y -q --type luks1 luksFormat /dev/"$rootpartition"; then echo
				else break
				fi
			done # while loop
			
			echo
			
			echo "${green}Opening /dev/$rootpartition...$end"
			while true; do
				if ! cryptsetup open /dev/"$rootpartition" cryptroot; then echo
				else break
				fi
			done # while loop
			
			# var stuff
			encrootpartition="mapper/cryptroot"
			oldrootpartition="$rootpartition"
			rootpartition="$encrootpartition"
			luks=true
			
			echo
			break
			;;
		n  | no | "" ) echo "Skipping..."; break ;;
	esac
done # while loop

clear

# TODO: clean up entire filesystem thing maybe
while true; do
	autocomplete ext4 f2fs xfs btrfs
	echo
	read -ep "Select the ${bold}root filesystem$end: (e)xt4, (f)2fs, (x)fs, (b)trfs [ext4] " filesystem
	case "$filesystem" in
		e | ext4 | "" | f | f2fs | b | btrfs | x | xfs ) break ;;
		* ) invalidoption ;;
	esac
done # while loop

echo "${green}Formatting the ${bold}root partition$end ${green}...$end"
echo
case "$filesystem" in
	e | "" | ext4 ) 
		mkfs.ext4 -F /dev/"$rootpartition" || exit 
		;;
	f | f2fs ) 
		mkfs.f2fs -f /dev/"$rootpartition" || exit 
		echo "f2fs-tools" >> packages
		;;
	b | btrfs )
		mkfs.btrfs -f /dev/"$rootpartition" || exit
		echo "btrfs-progs" >> packages
		;;
	x | xfs )
		mkfs.xfs -f /dev/"$rootpartition" || exit
		echo "xfsprogs" >> packages
		;;	
esac

echo

# mount partition/s
echo "${green}Mounting the partitions...$end"
mount /dev/"$rootpartition" "$mountpoint"
if [[ -n "$uefi" ]]; then
	mkdir "$mountpoint"/efi || exit
	mount /dev/"$efipartition" "$mountpoint"/efi || exit
fi

clear

echo "Updating the keyring..."
# yeahyeah -Sy bad
pacman --noconfirm -Sy archlinux-keyring || exit

echo

# create the package list
packages=/tmp/packages
packagesclean=/tmp/packagesclean
echo "${green}Writing the package list...$end"
cat << 'EOF' > $packages
linux
#linux-lts
linux-firmware
polkit

nano
#micro
#vim

neofetch
#man-db
#pipewire
EOF

echo

while true; do
	# edit package list
	echo "Add/uncomment packages which you want in the package list"
	echo "${yellow}Linux, the firmware, polkit, nano, and neofetch are installed by default$end"
	echo "(also base and base-devel but you can't remove those because the installer ${red}dies$end)"
	echo
	
	while true; do
		autocomplete nano vim skip
		read -ep "Do you want to edit the package list with (n)ano, (v)im, or (s)kip? [nano] " editor
		echo
		
		case "$editor" in
			n | nano | "" ) nano $packages; break ;;
			v | vim ) vim $packages; break ;;
			s | skip ) echo "${green}Skipping package list editing...$end"; break ;;
			* ) invalidoption ;;
		esac
	done # while loop
	
	echo
	
	# take the packages list and get rid of the comments
	echo "Cleaning up the package list..."
	grep -v "#" $packages > $packagesclean || exit
	
	echo
	
	# ask if user wants to enable parallel download for pacman/pacstrap
	while true; do
		read -ep "Enable ${yellow}parallel downloads$end for pacman? [y] " paralleldownloads
		case "$paralleldownloads" in
			y | yes | "" )
				sed -i 's/#ParallelDownloads/ParallelDownloads/g' /etc/pacman.conf
				break
				;;
			n | no )
				echo "Skipping..."
				break
				;;
		esac
	done # while loop

	clear

	# read the package list and install those packages
	echo "${green}Installing packages with pacstrap...$end"
	echo
	# using -P in case parallel downloads are used
	if ! pacstrap -P "$mountpoint" base base-devel - < $packagesclean; then
		echo
		echo "${red}Something went wrong!$end"
		echo "Read pacstrap message above"
		echo "Perhaps a space at the end of a package name?"
		read -n 1 -sp "Press any key to retry... "
		clear
	else break
	fi
done # while loop

# TODO: clean this up as well
declare -p uefi disk filesystem luks oldrootpartition rootpartition > "$mountpoint"/varstuff 2> /dev/null

echo

# make the fstab
echo "${green}Generating the fstab...$end"
genfstab -U "$mountpoint" > "$mountpoint"/etc/fstab || exit

clear

# fetch the second script from remote into chroot and make it executable
while true; do

	echo "${green}Fetching the second script...$end"
	echo

	# fetch the second script from remote
	if ! curl --connect-timeout 20 -fL https://raw.githubusercontent.com/WessellUrdata/archstart/for-pr/$secondScriptName > "$mountpoint"/$secondScriptName ; then
	# if ! curl --connect-timeout 20 -fL https://git.io/JtoeR -o $secondScriptName > "$mountpoint"/$secondScriptName ; then
		echo "${red}Something went wrong!$end"
		echo "Read the error message above"
		read -n 1 -sp "Press any key to retry... "
		clear
	else
		# make executable
		chmod +x "$mountpoint"/$secondScriptName
		break
	fi
	
done # while loop

# chroot in and run the second script
echo "${green}Chrooting...$end"
echo
arch-chroot $mountpoint ./$secondScriptName || exit

clear

# cleanup
echo "${green}Cleaning up files...$end"
rm "$mountpoint"/$secondScriptName "$mountpoint"/varstuff $packages $packagesclean

echo

# wait a bit because yes
sleep 1

# unmount the filesystems
echo "${green}Unmounting filesystem/s...$end"
umount -R "$mountpoint"

# luks stuff
if [[ "$luks" == true ]]; then cryptsetup close /dev/"$encrootpartition"; fi

echo

# end
echo "${bold}${green}Installation finished!$end"
read -n 1 -sp "Press any key to reboot... "
echo

reboot
